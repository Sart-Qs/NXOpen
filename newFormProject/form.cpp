//==============================================================================
//  WARNING!!  This file is overwritten by the Block UI Styler while generating
//  the automation code. Any modifications to this file will be lost after
//  generating the code again.
//
//       Filename:  D:\newFormProject\form.cpp
//
//        This file was generated by the NX Block UI Styler
//        Created by: aleks
//              Version: NX 2212
//              Date: 01-10-2024  (Format: mm-dd-yyyy)
//              Time: 08:25 (Format: hh-mm)
//
//==============================================================================

//==============================================================================
//  Purpose:  This TEMPLATE file contains C++ source to guide you in the
//  construction of your Block application dialog. The generation of your
//  dialog file (.dlx extension) is the first step towards dialog construction
//  within NX.  You must now create a NX Open application that
//  utilizes this file (.dlx).
//
//  The information in this file provides you with the following:
//
//  1.  Help on how to load and display your Block UI Styler dialog in NX
//      using APIs provided in NXOpen.BlockStyler namespace
//  2.  The empty callback methods (stubs) associated with your dialog items
//      have also been placed in this file. These empty methods have been
//      created simply to start you along with your coding requirements.
//      The method name, argument list and possible return values have already
//      been provided for you.
//==============================================================================

//------------------------------------------------------------------------------
//These includes are needed for the following template code
//------------------------------------------------------------------------------
#include "form.hpp"
using namespace NXOpen;
using namespace NXOpen::BlockStyler;

//------------------------------------------------------------------------------
// Initialize static variables
//------------------------------------------------------------------------------
Session *(form::theSession) = NULL;
UI *(form::theUI) = NULL;
//------------------------------------------------------------------------------
// Constructor for NX Styler class
//------------------------------------------------------------------------------
form::form()
{
    try
    {
        // Initialize the NX Open C++ API environment
        form::theSession = NXOpen::Session::GetSession();
        form::theUI = UI::GetUI();
        theDlxFileName = "form.dlx";
        theDialog = form::theUI->CreateDialog(theDlxFileName);
        // Registration of callback functions
        theDialog->AddApplyHandler(make_callback(this, &form::apply_cb));
        theDialog->AddOkHandler(make_callback(this, &form::ok_cb));
        theDialog->AddUpdateHandler(make_callback(this, &form::update_cb));
        theDialog->AddInitializeHandler(make_callback(this, &form::initialize_cb));
        theDialog->AddDialogShownHandler(make_callback(this, &form::dialogShown_cb));
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        throw;
    }
}

//------------------------------------------------------------------------------
// Destructor for NX Styler class
//------------------------------------------------------------------------------
form::~form()
{
    if (theDialog != NULL)
    {
        delete theDialog;
        theDialog = NULL;
    }
}
//------------------------------- DIALOG LAUNCHING ---------------------------------
//
//    Before invoking this application one needs to open any part/empty part in NX
//    because of the behavior of the blocks.
//
//    Make sure the dlx file is in one of the following locations:
//        1.) From where NX session is launched
//        2.) $UGII_USER_DIR/application
//        3.) For released applications, using UGII_CUSTOM_DIRECTORY_FILE is highly
//            recommended. This variable is set to a full directory path to a file 
//            containing a list of root directories for all custom applications.
//            e.g., UGII_CUSTOM_DIRECTORY_FILE=$UGII_BASE_DIR\ugii\menus\custom_dirs.dat
//
//    You can create the dialog using one of the following way:
//
//    1. USER EXIT
//
//        1) Create the Shared Library -- Refer "Block UI Styler programmer's guide"
//        2) Invoke the Shared Library through File->Execute->NX Open menu.
//
//------------------------------------------------------------------------------
extern "C" DllExport void  ufusr(char *param, int *retcod, int param_len)
{
    form *theform = NULL;
    try
    {
        theform = new form();
        // The following method shows the dialog immediately
        theform->Launch();
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        form::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
    if(theform != NULL)
    {
        delete theform;
        theform = NULL;
    }
}

//------------------------------------------------------------------------------
// This method specifies how a shared image is unloaded from memory
// within NX. This method gives you the capability to unload an
// internal NX Open application or user  exit from NX. Specify any
// one of the three constants as a return value to determine the type
// of unload to perform:
//
//
//    Immediately : unload the library as soon as the automation program has completed
//    Explicitly  : unload the library from the "Unload Shared Image" dialog
//    AtTermination : unload the library when the NX session terminates
//
//
// NOTE:  A program which associates NX Open applications with the menubar
// MUST NOT use this option since it will UNLOAD your NX Open application image
// from the menubar.
//------------------------------------------------------------------------------
extern "C" DllExport int ufusr_ask_unload()
{
    //return (int)Session::LibraryUnloadOptionExplicitly;
    return (int)Session::LibraryUnloadOptionImmediately;
    //return (int)Session::LibraryUnloadOptionAtTermination;
}

//------------------------------------------------------------------------------
// Following method cleanup any housekeeping chores that may be needed.
// This method is automatically called by NX.
//------------------------------------------------------------------------------
extern "C" DllExport void ufusr_cleanup(void)
{
    try
    {
        //---- Enter your callback code here -----
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        form::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
}

//------------------------------------------------------------------------------
//This method launches the dialog to screen
//------------------------------------------------------------------------------
NXOpen::BlockStyler::BlockDialog::DialogResponse form::Launch()
{
    NXOpen::BlockStyler::BlockDialog::DialogResponse dialogResponse= NXOpen::BlockStyler::BlockDialog::DialogResponse::DialogResponseInvalid;
    try
    {
        dialogResponse=theDialog->Launch();
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        form::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
    return dialogResponse;
}

//------------------------------------------------------------------------------
//---------------------Block UI Styler Callback Functions--------------------------
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
//Callback Name: initialize_cb
//------------------------------------------------------------------------------
void form::initialize_cb()
{
    try
    {
        group0 = dynamic_cast<NXOpen::BlockStyler::Group*>(theDialog->TopBlock()->FindBlock("group0"));
        double0 = dynamic_cast<NXOpen::BlockStyler::DoubleBlock*>(theDialog->TopBlock()->FindBlock("double0"));
        button0 = dynamic_cast<NXOpen::BlockStyler::Button*>(theDialog->TopBlock()->FindBlock("button0"));
        group = dynamic_cast<NXOpen::BlockStyler::Group*>(theDialog->TopBlock()->FindBlock("group"));
        button01 = dynamic_cast<NXOpen::BlockStyler::Button*>(theDialog->TopBlock()->FindBlock("button01"));
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        form::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
}

//------------------------------------------------------------------------------
//Callback Name: dialogShown_cb
//This callback is executed just before the dialog launch. Thus any value set 
//here will take precedence and dialog will be launched showing that value. 
//------------------------------------------------------------------------------
void form::dialogShown_cb()
{
    try
    {
        //---- Enter your callback code here -----
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        form::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
}

//------------------------------------------------------------------------------
//Callback Name: apply_cb
//------------------------------------------------------------------------------
int form::apply_cb()
{
    int errorCode = 0;
    try
    {
        //---- Enter your callback code here -----
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        errorCode = 1;
        form::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
    return errorCode;
}

//------------------------------------------------------------------------------
//Callback Name: update_cb
//------------------------------------------------------------------------------
int form::update_cb(NXOpen::BlockStyler::UIBlock* block)
{
    try
    {
        if(block == double0)
        {
        //---------Enter your code here-----------
        }
        else if(block == button0)
        {
        //---------Enter your code here-----------
            char t_a[] = "0.0";
            char a[] = "0.0";
            char b[] = "-4.0";
            char H[125];
            sprintf(H, "%f", double0->Value());
            // определим создание нового самостоятельного тела 
            UF_FEATURE_SIGN sign = UF_NULLSIGN;
            //это тело должно начинаться в заданных координатах Х, У, Z 
            double cyl_orig[3] = { 0.0,0.0,0.0 };
            char diam[125] = "8"; //диаметр
            //и орты направления главной диагонали координат будут по 1 
            double direction[3] = { 1.0, 0.0, 0.0 };
            tag_t cyl_obj; //определим переменную для будущего тега цилиндра

            //это тело должно начинаться в заданных координатах Х, У, Z 
            double cyl_orig1[3] = { -5.0,0.0,0.0 };
            char height1[125] = "5"; //высоту цилиндра зададим в 70 мм 
            char diam1[125] = "13"; //диаметр-в 50 мм 
            //и орты направления главной диагонали координат будут по 1 
            double direction1[3] = { 1.0, 0.0, 0.0 };
            tag_t cyl_obj1; //определим переменную для будущего тега цилиндра+



            tag_t lines[4] = { 0,1,2,3 }; // Идентификатор объекта «линия»
            UF_CURVE_line_t line[4];
            line[0].start_point[0] = -5.0; // X1
            line[0].start_point[1] = 1.5; // Y1
            line[0].start_point[2] = 7.0; // Z1
            line[0].end_point[0] = -5.0; // X2
            line[0].end_point[1] = 1.5; // Y2
            line[0].end_point[2] = -7.0; // Z2

            line[1].start_point[0] = -5.0; // X1
            line[1].start_point[1] = 1.5; // Y1
            line[1].start_point[2] = -7.0; // Z1
            line[1].end_point[0] = -5.0; // X2
            line[1].end_point[1] = -1.5; // Y2
            line[1].end_point[2] = -7.0; // Z2

            line[2].start_point[0] = -5.0; // X1
            line[2].start_point[1] = -1.5; // Y1
            line[2].start_point[2] = -7.0; // Z1
            line[2].end_point[0] = -5.0; // X2
            line[2].end_point[1] = -1.5; // Y2
            line[2].end_point[2] = 7.0; // Z2

            line[3].start_point[0] = -5.0; // X1
            line[3].start_point[1] = -1.5; // Y1
            line[3].start_point[2] = 7.0; // Z1
            line[3].end_point[0] = -5.0; // X2
            line[3].end_point[1] = 1.5; // Y2
            line[3].end_point[2] = 7.0; // Z2

            uf_list_p_t list, //Список объектов, подлежащих выдавливанию (элементы сечения)
                features; //Список созданных идентификаторов объектов
            UF_MODL_create_list(&list);//создание пустого перечня объектов
            char* taper_angle = t_a;//Конусность
            char* limit[2] = { a, b };//Начало и конец выдавливания
            double ref_pt[4];//параметр не используется
            double dir[3] = { -1.0, 0.0, 0.0 };//Вектор выдавливания
            UF_FEATURE_SIGN create = UF_NEGATIVE;

            for (int i = 0; i < 4; i++)
            {
                UF_CURVE_create_line(&line[i], &lines[i]);
                UF_MODL_put_list_item(list, lines[i]);
            }

            if (!UF_initialize())
            {
                //выполним построение цилиндра 
                UF_MODL_create_cyl1(sign, cyl_orig, H, diam, direction, &cyl_obj);
                UF_MODL_create_cyl1(sign, cyl_orig1, height1, diam1, direction1, &cyl_obj1);
                UF_MODL_create_extruded(list, taper_angle, limit, ref_pt, dir, create, &features);
            }
        }
        else if(block == button01)
        {
        //---------Enter your code here-----------+
            char t_a[] = "0.0";
            char a[] = "0.0";
            char b[] = "5.0";
            char c[] = "5.0";
            if (!UF_initialize())
            {
                tag_t objarray[4]; //тег для двух линий и двух дуг

                UF_FEATURE_SIGN sign = UF_NULLSIGN;
                tag_t lines[] = { 0,1,2,3,4,5,6 }; // Идентификатор объекта «линия»
                UF_CURVE_line_t line[7];

                uf_list_p_t list, //Список объектов, подлежащих выдавливанию (элементы сечения)
                    features; //Список созданных идентификаторов объектов
                UF_MODL_create_list(&list);//создание пустого перечня объектов
                char* taper_angle = t_a;//Конусность
                char* limit[2] = { a, b };//Начало и конец выдавливания
                double ref_pt[4];//параметр не используется
                double dir[3] = { 0.0, 1.0, 0.0 };//Вектор выдавливания
                UF_FEATURE_SIGN create = UF_NULLSIGN;

                uf_list_p_t list1, //Список объектов, подлежащих выдавливанию (элементы сечения)
                    features1; //Список созданных идентификаторов объектов
                UF_MODL_create_list(&list1);//создание пустого перечня объектов
                double ref_pt1[3];
                double dir1[3] = { -1.0, 0.0, 0.0 };//Вектор выдавливания
                UF_FEATURE_SIGN create1 = UF_POSITIVE;

                line[0].start_point[0] = 0.0; // X1
                line[0].start_point[1] = 0.0; // Y1
                line[0].start_point[2] = 0.0; // Z1
                line[0].end_point[0] = 0.0; // X2
                line[0].end_point[1] = 0.0; // Y2
                line[0].end_point[2] = 25.0; // Z2

                line[1].start_point[0] = 0.0; // X1
                line[1].start_point[1] = 0.0; // Y1
                line[1].start_point[2] = 25.0; // Z1
                line[1].end_point[0] = 160.0; // X2
                line[1].end_point[1] = 0.0; // Y2
                line[1].end_point[2] = 25.0; // Z2

                line[2].start_point[0] = 160.0; // X1
                line[2].start_point[1] = 0.0; // Y1
                line[2].start_point[2] = 25.0; // Z1
                line[2].end_point[0] = 160.0; // X2
                line[2].end_point[1] = 0.0; // Y2
                line[2].end_point[2] = 0.0; // Z2

                line[3].start_point[0] = 160.0; // X1
                line[3].start_point[1] = 0.0; // Y1
                line[3].start_point[2] = 0.0; // Z1
                line[3].end_point[0] = 0.0; // X2
                line[3].end_point[1] = 0.0; // Y2
                line[3].end_point[2] = 0.0; // Z2

                line[4].start_point[0] = 160.0; // X1
                line[4].start_point[1] = 0.0; // Y1
                line[4].start_point[2] = 25.0; // Z1
                line[4].end_point[0] = 160.0; // X2
                line[4].end_point[1] = 50.0; // Y2
                line[4].end_point[2] = 25.0; // Z2

                line[5].start_point[0] = 160.0; // X1
                line[5].start_point[1] = 50.0; // Y1
                line[5].start_point[2] = 25.0; // Z1
                line[5].end_point[0] = 160.0; // X2
                line[5].end_point[1] = 50.0; // Y2
                line[5].end_point[2] = 0.0; // Z2

                line[6].start_point[0] = 160.0; // X1
                line[6].start_point[1] = 50.0; // Y1
                line[6].start_point[2] = 0.0; // Z1
                line[6].end_point[0] = 160.0; // X2
                line[6].end_point[1] = 0.0; // Y2
                line[6].end_point[2] = 0.0; // Z2


                tag_t arc_id, wcs_tag; //тэги окружности
                //и мировой системы координат 
                UF_CURVE_arc_t arc_coords; //структура свойств дуги
                // объявление данных для матрицы поворота
                //зададим угол 45° и пересчитаем его в радианы
                double ugol_Y = 45 * DEGRA;
                // объявим вектора осей Х и У
                double vec_X[3] = { 1, 0, 0 };

                //объявим матрицы поворотов:
                double mtxP[9], //вокруг оси Х
                    mt[9]; //суммарную матрицу поворота

                //объявим теги систем координат
                tag_t teg_wcs, csys_id;
                // объявим точку начала координат
                double center[3] = { 0,0,0 };

                // начало кода работы с матрицами
                // получим матрицу поворота вокруг оси Х
                UF_MTX3_rotate_about_axis(vec_X, ugol_Y, mtxP);
                // перемножением получим суммарную матрицу поворота по обоим углам
                UF_MTX3_multiply(mtxP, mtxP, mt);
                // создадим тег суммарной матрицы поворота
                UF_CSYS_create_matrix(mt, &teg_wcs);
                // создадим тег системы координат на базе полученной матрицы
                UF_CSYS_create_csys(center, teg_wcs, &csys_id);
                // установим на экране созданную рабочую систему координат
                UF_CSYS_set_wcs(csys_id);
                // начало кода построения окружности
                arc_coords.start_angle = 90.0 * DEGRA; //начальный угол окружности
                arc_coords.end_angle = 270 * DEGRA; //конечный угол
                arc_coords.arc_center[0] = 15.0; //координата центра Х
                arc_coords.arc_center[1] = -12.5; //координата центра Y 
                arc_coords.arc_center[2] = 0.0; //координата центра Z 
                arc_coords.radius = 4.5; //радиус окружности
                UF_CSYS_ask_wcs(&wcs_tag); //получение абсолютных координат
                //"перенос" абсолютных координат на создаваемую окружность
                UF_CSYS_ask_matrix_of_object(wcs_tag, &arc_coords.matrix_tag);

                tag_t lineForNEG[] = { 0,1 };
                UF_CURVE_line_t lForNEG[2];

                lForNEG[0].start_point[0] = 15.0; // X1
                lForNEG[0].start_point[1] = 0.0; // Y1
                lForNEG[0].start_point[2] = 17.0; // Z1
                lForNEG[0].end_point[0] = 140.0; // X2
                lForNEG[0].end_point[1] = 0.0; // Y2
                lForNEG[0].end_point[2] = 17.0; // Z2

                lForNEG[1].start_point[0] = 15.0; // X1
                lForNEG[1].start_point[1] = 0.0; // Y1
                lForNEG[1].start_point[2] = 8.0; // Z1
                lForNEG[1].end_point[0] = 140.0; // X2
                lForNEG[1].end_point[1] = 0.0; // Y2
                lForNEG[1].end_point[2] = 8.0; // Z2


                tag_t arc_id1, wcs_tag1; //тэги окружности
                //и мировой системы координат 
                UF_CURVE_arc_t arc_coords1; //структура свойств дуги
                // объявление данных для матрицы поворота
                //зададим угол 45° и пересчитаем его в радианы
                double ugol_Y1 = 45 * DEGRA;
                // объявим вектора осей Х и У
                double vec_X1[3] = { 1, 0, 0 };

                //объявим матрицы поворотов:
                double mtxP1[9], //вокруг оси Х
                    mt1[9]; //суммарную матрицу поворота

                //объявим теги систем координат
                tag_t teg_wcs1, csys_id1;
                // объявим точку начала координат
                double center1[3] = { 0,0,0 };
                // начало кода работы с матрицами
                // получим матрицу поворота вокруг оси Х
                UF_MTX3_rotate_about_axis(vec_X1, ugol_Y1, mtxP1);
                // перемножением получим суммарную матрицу поворота по обоим углам
                UF_MTX3_multiply(mtxP1, mtxP1, mt1);
                // создадим тег суммарной матрицы поворота
                UF_CSYS_create_matrix(mt1, &teg_wcs1);
                // создадим тег системы координат на базе полученной матрицы
                UF_CSYS_create_csys(center1, teg_wcs1, &csys_id1);
                // установим на экране созданную рабочую систему координат
                UF_CSYS_set_wcs(csys_id1);
                // начало кода построения окружности
                arc_coords1.start_angle = -90 * DEGRA; //начальный угол окружности
                arc_coords1.end_angle = 90 * DEGRA; //конечный угол
                arc_coords1.arc_center[0] = 140.0; //координата центра Х
                arc_coords1.arc_center[1] = -12.5; //координата центра Y 
                arc_coords1.arc_center[2] = 0.0; //координата центра Z 
                arc_coords1.radius = 4.5; //радиус окружности
                UF_CSYS_ask_wcs(&wcs_tag1); //получение абсолютных координат
                //"перенос" абсолютных координат на создаваемую окружность
                UF_CSYS_ask_matrix_of_object(wcs_tag1, &arc_coords1.matrix_tag);;

                uf_list_p_t list2, //Список объектов, подлежащих выдавливанию (элементы сечения)
                    features2; //Список созданных идентификаторов объектов
                double ref_pt2[3];
                double dir2[3] = { 0.0, 1.0, 0.0 };//Вектор выдавливания
                UF_FEATURE_SIGN create2 = UF_NEGATIVE;
                char* limit2[2] = { a, c };

                for (int i = 0; i < 4; i++)
                {
                    UF_CURVE_create_line(&line[i], &lines[i]);
                    UF_MODL_put_list_item(list, lines[i]);
                }
                UF_MODL_create_extruded(list, taper_angle, limit, ref_pt, dir, create, &features);
                UF_MODL_put_list_item(list1, lines[2]);
                for (int i = 4; i < 7; i++)
                {
                    UF_CURVE_create_line(&line[i], &lines[i]);
                    UF_MODL_put_list_item(list1, lines[i]);
                }
                UF_MODL_create_extruded(list1, taper_angle, limit, ref_pt1, dir1, create1, &features1);

                UF_CURVE_create_line(&lForNEG[0], &objarray[0]);
                UF_CURVE_create_line(&lForNEG[1], &objarray[1]);
                UF_CURVE_create_arc(&arc_coords, &objarray[2]);
                UF_CURVE_create_arc(&arc_coords1, &objarray[3]);
                UF_MODL_create_list(&list2);//создание пустого перечня объектов

                for (int i = 0; i < 4; i++)
                {
                    UF_MODL_put_list_item(list2, objarray[i]);
                }
                UF_MODL_create_extruded(list2, taper_angle, limit2, ref_pt2, dir2, create2, &features2);

            }
        }
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        form::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
    return 0;
}

//------------------------------------------------------------------------------
//Callback Name: ok_cb
//------------------------------------------------------------------------------
int form::ok_cb()
{
    int errorCode = 0;
    try
    {
        errorCode = apply_cb();
    }
    catch(exception& ex)
    {
        //---- Enter your exception handling code here -----
        errorCode = 1;
        form::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
    return errorCode;
}

int form::Show()
{
    try
    {
        theDialog->Show();
    }
    catch (exception& ex)
    {
        //---- Enter your exception handling code here -----
        form::theUI->NXMessageBox()->Show("Block Styler", NXOpen::NXMessageBox::DialogTypeError, ex.what());
    }
    return 0;
}

//------------------------------------------------------------------------------
//Function Name: GetBlockProperties
//Description: Returns the propertylist of the specified BlockID
//------------------------------------------------------------------------------
PropertyList* form::GetBlockProperties(const char *blockID)
{
    return theDialog->GetBlockProperties(blockID);
}
